{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nvar _excluded = [\"name\"];\nimport toChildrenArray from \"rc-util/es/Children/toArray\";\nimport warning from \"rc-util/es/warning\";\nimport isEqual from \"rc-util/es/isEqual\";\nimport * as React from 'react';\nimport FieldContext, { HOOK_MARK } from './FieldContext';\nimport ListContext from './ListContext';\nimport { toArray } from './utils/typeUtil';\nimport { validateRules } from './utils/validateUtil';\nimport { containsNamePath, defaultGetValueFromEvent, getNamePath, getValue } from './utils/valueUtil';\nvar EMPTY_ERRORS = [];\nfunction requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {\n  if (typeof shouldUpdate === 'function') {\n    return shouldUpdate(prev, next, 'source' in info ? {\n      source: info.source\n    } : {});\n  }\n  return prevValue !== nextValue;\n}\n// We use Class instead of Hooks here since it will cost much code by using Hooks.\nvar Field = /*#__PURE__*/function (_React$Component) {\n  _inherits(Field, _React$Component);\n  var _super = _createSuper(Field);\n  // ============================== Subscriptions ==============================\n  function Field(props) {\n    var _this;\n    _classCallCheck(this, Field);\n    _this = _super.call(this, props);\n    // Register on init\n    _this.state = {\n      resetCount: 0\n    };\n    _this.cancelRegisterFunc = null;\n    _this.mounted = false;\n    /**\r\n     * Follow state should not management in State since it will async update by React.\r\n     * This makes first render of form can not get correct state value.\r\n     */\n    _this.touched = false;\n    /**\r\n     * Mark when touched & validated. Currently only used for `dependencies`.\r\n     * Note that we do not think field with `initialValue` is dirty\r\n     * but this will be by `isFieldDirty` func.\r\n     */\n    _this.dirty = false;\n    _this.validatePromise = void 0;\n    _this.prevValidating = void 0;\n    _this.errors = EMPTY_ERRORS;\n    _this.warnings = EMPTY_ERRORS;\n    _this.cancelRegister = function () {\n      var _this$props = _this.props,\n        preserve = _this$props.preserve,\n        isListField = _this$props.isListField,\n        name = _this$props.name;\n      if (_this.cancelRegisterFunc) {\n        _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));\n      }\n      _this.cancelRegisterFunc = null;\n    };\n    // ================================== Utils ==================================\n    _this.getNamePath = function () {\n      var _this$props2 = _this.props,\n        name = _this$props2.name,\n        fieldContext = _this$props2.fieldContext;\n      var _fieldContext$prefixN = fieldContext.prefixName,\n        prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;\n      return name !== undefined ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];\n    };\n    _this.getRules = function () {\n      var _this$props3 = _this.props,\n        _this$props3$rules = _this$props3.rules,\n        rules = _this$props3$rules === void 0 ? [] : _this$props3$rules,\n        fieldContext = _this$props3.fieldContext;\n      return rules.map(function (rule) {\n        if (typeof rule === 'function') {\n          return rule(fieldContext);\n        }\n        return rule;\n      });\n    };\n    _this.refresh = function () {\n      if (!_this.mounted) return;\n      /**\r\n       * Clean up current node.\r\n       */\n      _this.setState(function (_ref) {\n        var resetCount = _ref.resetCount;\n        return {\n          resetCount: resetCount + 1\n        };\n      });\n    };\n    // Event should only trigger when meta changed\n    _this.metaCache = null;\n    _this.triggerMetaEvent = function (destroy) {\n      var onMetaChange = _this.props.onMetaChange;\n      if (onMetaChange) {\n        var meta = _objectSpread(_objectSpread({}, _this.getMeta()), {}, {\n          destroy: destroy\n        });\n        if (!isEqual(_this.metaCache, meta)) {\n          onMetaChange(meta);\n        }\n        _this.metaCache = meta;\n      } else {\n        _this.metaCache = null;\n      }\n    };\n    // ========================= Field Entity Interfaces =========================\n    // Trigger by store update. Check if need update the component\n    _this.onStoreChange = function (prevStore, namePathList, info) {\n      var _this$props4 = _this.props,\n        shouldUpdate = _this$props4.shouldUpdate,\n        _this$props4$dependen = _this$props4.dependencies,\n        dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen,\n        onReset = _this$props4.onReset;\n      var store = info.store;\n      var namePath = _this.getNamePath();\n      var prevValue = _this.getValue(prevStore);\n      var curValue = _this.getValue(store);\n      var namePathMatch = namePathList && containsNamePath(namePathList, namePath);\n      // `setFieldsValue` is a quick access to update related status\n      if (info.type === 'valueUpdate' && info.source === 'external' && prevValue !== curValue) {\n        _this.touched = true;\n        _this.dirty = true;\n        _this.validatePromise = null;\n        _this.errors = EMPTY_ERRORS;\n        _this.warnings = EMPTY_ERRORS;\n        _this.triggerMetaEvent();\n      }\n      switch (info.type) {\n        case 'reset':\n          if (!namePathList || namePathMatch) {\n            // Clean up state\n            _this.touched = false;\n            _this.dirty = false;\n            _this.validatePromise = undefined;\n            _this.errors = EMPTY_ERRORS;\n            _this.warnings = EMPTY_ERRORS;\n            _this.triggerMetaEvent();\n            onReset === null || onReset === void 0 ? void 0 : onReset();\n            _this.refresh();\n            return;\n          }\n          break;\n        /**\r\n         * In case field with `preserve = false` nest deps like:\r\n         * - A = 1 => show B\r\n         * - B = 1 => show C\r\n         * - Reset A, need clean B, C\r\n         */\n        case 'remove':\n          {\n            if (shouldUpdate) {\n              _this.reRender();\n              return;\n            }\n            break;\n          }\n        case 'setField':\n          {\n            if (namePathMatch) {\n              var data = info.data;\n              if ('touched' in data) {\n                _this.touched = data.touched;\n              }\n              if ('validating' in data && !('originRCField' in data)) {\n                _this.validatePromise = data.validating ? Promise.resolve([]) : null;\n              }\n              if ('errors' in data) {\n                _this.errors = data.errors || EMPTY_ERRORS;\n              }\n              if ('warnings' in data) {\n                _this.warnings = data.warnings || EMPTY_ERRORS;\n              }\n              _this.dirty = true;\n              _this.triggerMetaEvent();\n              _this.reRender();\n              return;\n            }\n            // Handle update by `setField` with `shouldUpdate`\n            if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n              _this.reRender();\n              return;\n            }\n            break;\n          }\n        case 'dependenciesUpdate':\n          {\n            /**\r\n             * Trigger when marked `dependencies` updated. Related fields will all update\r\n             */\n            var dependencyList = dependencies.map(getNamePath);\n            // No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be\n            // emitted earlier and they will work there\n            // If set it may cause unnecessary twice rerendering\n            if (dependencyList.some(function (dependency) {\n              return containsNamePath(info.relatedFields, dependency);\n            })) {\n              _this.reRender();\n              return;\n            }\n            break;\n          }\n        default:\n          // 1. If `namePath` exists in `namePathList`, means it's related value and should update\n          //      For example <List name=\"list\"><Field name={['list', 0]}></List>\n          //      If `namePathList` is [['list']] (List value update), Field should be updated\n          //      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated\n          // 2.\n          //   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,\n          //       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`\n          //       is not provided\n          //   2.2 If `shouldUpdate` provided, use customize logic to update the field\n          //       else to check if value changed\n          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            _this.reRender();\n            return;\n          }\n          break;\n      }\n      if (shouldUpdate === true) {\n        _this.reRender();\n      }\n    };\n    _this.validateRules = function (options) {\n      // We should fixed namePath & value to avoid developer change then by form function\n      var namePath = _this.getNamePath();\n      var currentValue = _this.getValue();\n      var _ref2 = options || {},\n        triggerName = _ref2.triggerName,\n        _ref2$validateOnly = _ref2.validateOnly,\n        validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;\n      // Force change to async to avoid rule OOD under renderProps field\n      var rootPromise = Promise.resolve().then(function () {\n        if (!_this.mounted) {\n          return [];\n        }\n        var _this$props5 = _this.props,\n          _this$props5$validate = _this$props5.validateFirst,\n          validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate,\n          messageVariables = _this$props5.messageVariables;\n        var filteredRules = _this.getRules();\n        if (triggerName) {\n          filteredRules = filteredRules.filter(function (rule) {\n            return rule;\n          }).filter(function (rule) {\n            var validateTrigger = rule.validateTrigger;\n            if (!validateTrigger) {\n              return true;\n            }\n            var triggerList = toArray(validateTrigger);\n            return triggerList.includes(triggerName);\n          });\n        }\n        var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);\n        promise.catch(function (e) {\n          return e;\n        }).then(function () {\n          var ruleErrors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_ERRORS;\n          if (_this.validatePromise === rootPromise) {\n            var _ruleErrors$forEach;\n            _this.validatePromise = null;\n            // Get errors & warnings\n            var nextErrors = [];\n            var nextWarnings = [];\n            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function (_ref3) {\n              var warningOnly = _ref3.rule.warningOnly,\n                _ref3$errors = _ref3.errors,\n                errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;\n              if (warningOnly) {\n                nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));\n              } else {\n                nextErrors.push.apply(nextErrors, _toConsumableArray(errors));\n              }\n            });\n            _this.errors = nextErrors;\n            _this.warnings = nextWarnings;\n            _this.triggerMetaEvent();\n            _this.reRender();\n          }\n        });\n        return promise;\n      });\n      if (validateOnly) {\n        return rootPromise;\n      }\n      _this.validatePromise = rootPromise;\n      _this.dirty = true;\n      _this.errors = EMPTY_ERRORS;\n      _this.warnings = EMPTY_ERRORS;\n      _this.triggerMetaEvent();\n      // Force trigger re-render since we need sync renderProps with new meta\n      _this.reRender();\n      return rootPromise;\n    };\n    _this.isFieldValidating = function () {\n      return !!_this.validatePromise;\n    };\n    _this.isFieldTouched = function () {\n      return _this.touched;\n    };\n    _this.isFieldDirty = function () {\n      // Touched or validate or has initialValue\n      if (_this.dirty || _this.props.initialValue !== undefined) {\n        return true;\n      }\n      // Form set initialValue\n      var fieldContext = _this.props.fieldContext;\n      var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK),\n        getInitialValue = _fieldContext$getInte.getInitialValue;\n      if (getInitialValue(_this.getNamePath()) !== undefined) {\n        return true;\n      }\n      return false;\n    };\n    _this.getErrors = function () {\n      return _this.errors;\n    };\n    _this.getWarnings = function () {\n      return _this.warnings;\n    };\n    _this.isListField = function () {\n      return _this.props.isListField;\n    };\n    _this.isList = function () {\n      return _this.props.isList;\n    };\n    _this.isPreserve = function () {\n      return _this.props.preserve;\n    };\n    // ============================= Child Component =============================\n    _this.getMeta = function () {\n      // Make error & validating in cache to save perf\n      _this.prevValidating = _this.isFieldValidating();\n      var meta = {\n        touched: _this.isFieldTouched(),\n        validating: _this.prevValidating,\n        errors: _this.errors,\n        warnings: _this.warnings,\n        name: _this.getNamePath(),\n        validated: _this.validatePromise === null\n      };\n      return meta;\n    };\n    // Only return validate child node. If invalidate, will do nothing about field.\n    _this.getOnlyChild = function (children) {\n      // Support render props\n      if (typeof children === 'function') {\n        var meta = _this.getMeta();\n        return _objectSpread(_objectSpread({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {\n          isFunction: true\n        });\n      }\n      // Filed element only\n      var childList = toChildrenArray(children);\n      if (childList.length !== 1 || ! /*#__PURE__*/React.isValidElement(childList[0])) {\n        return {\n          child: childList,\n          isFunction: false\n        };\n      }\n      return {\n        child: childList[0],\n        isFunction: false\n      };\n    };\n    // ============================== Field Control ==============================\n    _this.getValue = function (store) {\n      var getFieldsValue = _this.props.fieldContext.getFieldsValue;\n      var namePath = _this.getNamePath();\n      return getValue(store || getFieldsValue(true), namePath);\n    };\n    _this.getControlled = function () {\n      var childProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$props6 = _this.props,\n        trigger = _this$props6.trigger,\n        validateTrigger = _this$props6.validateTrigger,\n        getValueFromEvent = _this$props6.getValueFromEvent,\n        normalize = _this$props6.normalize,\n        valuePropName = _this$props6.valuePropName,\n        getValueProps = _this$props6.getValueProps,\n        fieldContext = _this$props6.fieldContext;\n      var mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\n      var namePath = _this.getNamePath();\n      var getInternalHooks = fieldContext.getInternalHooks,\n        getFieldsValue = fieldContext.getFieldsValue;\n      var _getInternalHooks = getInternalHooks(HOOK_MARK),\n        dispatch = _getInternalHooks.dispatch;\n      var value = _this.getValue();\n      var mergedGetValueProps = getValueProps || function (val) {\n        return _defineProperty({}, valuePropName, val);\n      };\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var originTriggerFunc = childProps[trigger];\n      var control = _objectSpread(_objectSpread({}, childProps), mergedGetValueProps(value));\n      // Add trigger\n      control[trigger] = function () {\n        // Mark as touched\n        _this.touched = true;\n        _this.dirty = true;\n        _this.triggerMetaEvent();\n        var newValue;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        if (getValueFromEvent) {\n          newValue = getValueFromEvent.apply(void 0, args);\n        } else {\n          newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));\n        }\n        if (normalize) {\n          newValue = normalize(newValue, value, getFieldsValue(true));\n        }\n        dispatch({\n          type: 'updateValue',\n          namePath: namePath,\n          value: newValue\n        });\n        if (originTriggerFunc) {\n          originTriggerFunc.apply(void 0, args);\n        }\n      };\n      // Add validateTrigger\n      var validateTriggerList = toArray(mergedValidateTrigger || []);\n      validateTriggerList.forEach(function (triggerName) {\n        // Wrap additional function of component, so that we can get latest value from store\n        var originTrigger = control[triggerName];\n        control[triggerName] = function () {\n          if (originTrigger) {\n            originTrigger.apply(void 0, arguments);\n          }\n          // Always use latest rules\n          var rules = _this.props.rules;\n          if (rules && rules.length) {\n            // We dispatch validate to root,\n            // since it will update related data with other field with same name\n            dispatch({\n              type: 'validateField',\n              namePath: namePath,\n              triggerName: triggerName\n            });\n          }\n        };\n      });\n      return control;\n    };\n    if (props.fieldContext) {\n      var getInternalHooks = props.fieldContext.getInternalHooks;\n      var _getInternalHooks2 = getInternalHooks(HOOK_MARK),\n        initEntityValue = _getInternalHooks2.initEntityValue;\n      initEntityValue(_assertThisInitialized(_this));\n    }\n    return _this;\n  }\n  _createClass(Field, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props7 = this.props,\n        shouldUpdate = _this$props7.shouldUpdate,\n        fieldContext = _this$props7.fieldContext;\n      this.mounted = true;\n      // Register on init\n      if (fieldContext) {\n        var getInternalHooks = fieldContext.getInternalHooks;\n        var _getInternalHooks3 = getInternalHooks(HOOK_MARK),\n          registerField = _getInternalHooks3.registerField;\n        this.cancelRegisterFunc = registerField(this);\n      }\n      // One more render for component in case fields not ready\n      if (shouldUpdate === true) {\n        this.reRender();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.cancelRegister();\n      this.triggerMetaEvent(true);\n      this.mounted = false;\n    }\n  }, {\n    key: \"reRender\",\n    value: function reRender() {\n      if (!this.mounted) return;\n      this.forceUpdate();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var resetCount = this.state.resetCount;\n      var children = this.props.children;\n      var _this$getOnlyChild = this.getOnlyChild(children),\n        child = _this$getOnlyChild.child,\n        isFunction = _this$getOnlyChild.isFunction;\n      // Not need to `cloneElement` since user can handle this in render function self\n      var returnChildNode;\n      if (isFunction) {\n        returnChildNode = child;\n      } else if ( /*#__PURE__*/React.isValidElement(child)) {\n        returnChildNode = /*#__PURE__*/React.cloneElement(child, this.getControlled(child.props));\n      } else {\n        warning(!child, '`children` of Field is not validate ReactElement.');\n        returnChildNode = child;\n      }\n      return /*#__PURE__*/React.createElement(React.Fragment, {\n        key: resetCount\n      }, returnChildNode);\n    }\n  }]);\n  return Field;\n}(React.Component);\nField.contextType = FieldContext;\nField.defaultProps = {\n  trigger: 'onChange',\n  valuePropName: 'value'\n};\nfunction WrapperField(_ref5) {\n  var name = _ref5.name,\n    restProps = _objectWithoutProperties(_ref5, _excluded);\n  var fieldContext = React.useContext(FieldContext);\n  var listContext = React.useContext(ListContext);\n  var namePath = name !== undefined ? getNamePath(name) : undefined;\n  var key = 'keep';\n  if (!restProps.isListField) {\n    key = \"_\".concat((namePath || []).join('_'));\n  }\n  // Warning if it's a directly list field.\n  // We can still support multiple level field preserve.\n  if (process.env.NODE_ENV !== 'production' && restProps.preserve === false && restProps.isListField && namePath.length <= 1) {\n    warning(false, '`preserve` should not apply on Form.List fields.');\n  }\n  return /*#__PURE__*/React.createElement(Field, _extends({\n    key: key,\n    name: namePath,\n    isListField: !!listContext\n  }, restProps, {\n    fieldContext: fieldContext\n  }));\n}\nexport default WrapperField;","map":{"version":3,"names":["_extends","_objectWithoutProperties","_defineProperty","_objectSpread","_toConsumableArray","_classCallCheck","_createClass","_assertThisInitialized","_inherits","_createSuper","_excluded","toChildrenArray","warning","isEqual","React","FieldContext","HOOK_MARK","ListContext","toArray","validateRules","containsNamePath","defaultGetValueFromEvent","getNamePath","getValue","EMPTY_ERRORS","requireUpdate","shouldUpdate","prev","next","prevValue","nextValue","info","source","Field","_React$Component","_super","props","_this","call","state","resetCount","cancelRegisterFunc","mounted","touched","dirty","validatePromise","prevValidating","errors","warnings","cancelRegister","_this$props","preserve","isListField","name","_this$props2","fieldContext","_fieldContext$prefixN","prefixName","undefined","concat","getRules","_this$props3","_this$props3$rules","rules","map","rule","refresh","setState","_ref","metaCache","triggerMetaEvent","destroy","onMetaChange","meta","getMeta","onStoreChange","prevStore","namePathList","_this$props4","_this$props4$dependen","dependencies","onReset","store","namePath","curValue","namePathMatch","type","reRender","data","validating","Promise","resolve","length","dependencyList","some","dependency","relatedFields","options","currentValue","_ref2","triggerName","_ref2$validateOnly","validateOnly","rootPromise","then","_this$props5","_this$props5$validate","validateFirst","messageVariables","filteredRules","filter","validateTrigger","triggerList","includes","promise","catch","e","ruleErrors","arguments","_ruleErrors$forEach","nextErrors","nextWarnings","forEach","_ref3","warningOnly","_ref3$errors","push","apply","isFieldValidating","isFieldTouched","isFieldDirty","initialValue","_fieldContext$getInte","getInternalHooks","getInitialValue","getErrors","getWarnings","isList","isPreserve","validated","getOnlyChild","children","getControlled","isFunction","childList","isValidElement","child","getFieldsValue","childProps","_this$props6","trigger","getValueFromEvent","normalize","valuePropName","getValueProps","mergedValidateTrigger","_getInternalHooks","dispatch","value","mergedGetValueProps","val","originTriggerFunc","control","newValue","_len","args","Array","_key","validateTriggerList","originTrigger","_getInternalHooks2","initEntityValue","key","componentDidMount","_this$props7","_getInternalHooks3","registerField","componentWillUnmount","forceUpdate","render","_this$getOnlyChild","returnChildNode","cloneElement","createElement","Fragment","Component","contextType","defaultProps","WrapperField","_ref5","restProps","useContext","listContext","join","process","env","NODE_ENV"],"sources":["C:/Users/user/Desktop/MusicHub-ec2/popol2/node_modules/rc-field-form/es/Field.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\r\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\r\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\r\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\r\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\r\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\r\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\r\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\r\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\r\nvar _excluded = [\"name\"];\r\nimport toChildrenArray from \"rc-util/es/Children/toArray\";\r\nimport warning from \"rc-util/es/warning\";\r\nimport isEqual from \"rc-util/es/isEqual\";\r\nimport * as React from 'react';\r\nimport FieldContext, { HOOK_MARK } from './FieldContext';\r\nimport ListContext from './ListContext';\r\nimport { toArray } from './utils/typeUtil';\r\nimport { validateRules } from './utils/validateUtil';\r\nimport { containsNamePath, defaultGetValueFromEvent, getNamePath, getValue } from './utils/valueUtil';\r\nvar EMPTY_ERRORS = [];\r\nfunction requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {\r\n  if (typeof shouldUpdate === 'function') {\r\n    return shouldUpdate(prev, next, 'source' in info ? {\r\n      source: info.source\r\n    } : {});\r\n  }\r\n  return prevValue !== nextValue;\r\n}\r\n// We use Class instead of Hooks here since it will cost much code by using Hooks.\r\nvar Field = /*#__PURE__*/function (_React$Component) {\r\n  _inherits(Field, _React$Component);\r\n  var _super = _createSuper(Field);\r\n  // ============================== Subscriptions ==============================\r\n  function Field(props) {\r\n    var _this;\r\n    _classCallCheck(this, Field);\r\n    _this = _super.call(this, props);\r\n    // Register on init\r\n    _this.state = {\r\n      resetCount: 0\r\n    };\r\n    _this.cancelRegisterFunc = null;\r\n    _this.mounted = false;\r\n    /**\r\n     * Follow state should not management in State since it will async update by React.\r\n     * This makes first render of form can not get correct state value.\r\n     */\r\n    _this.touched = false;\r\n    /**\r\n     * Mark when touched & validated. Currently only used for `dependencies`.\r\n     * Note that we do not think field with `initialValue` is dirty\r\n     * but this will be by `isFieldDirty` func.\r\n     */\r\n    _this.dirty = false;\r\n    _this.validatePromise = void 0;\r\n    _this.prevValidating = void 0;\r\n    _this.errors = EMPTY_ERRORS;\r\n    _this.warnings = EMPTY_ERRORS;\r\n    _this.cancelRegister = function () {\r\n      var _this$props = _this.props,\r\n        preserve = _this$props.preserve,\r\n        isListField = _this$props.isListField,\r\n        name = _this$props.name;\r\n      if (_this.cancelRegisterFunc) {\r\n        _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));\r\n      }\r\n      _this.cancelRegisterFunc = null;\r\n    };\r\n    // ================================== Utils ==================================\r\n    _this.getNamePath = function () {\r\n      var _this$props2 = _this.props,\r\n        name = _this$props2.name,\r\n        fieldContext = _this$props2.fieldContext;\r\n      var _fieldContext$prefixN = fieldContext.prefixName,\r\n        prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;\r\n      return name !== undefined ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];\r\n    };\r\n    _this.getRules = function () {\r\n      var _this$props3 = _this.props,\r\n        _this$props3$rules = _this$props3.rules,\r\n        rules = _this$props3$rules === void 0 ? [] : _this$props3$rules,\r\n        fieldContext = _this$props3.fieldContext;\r\n      return rules.map(function (rule) {\r\n        if (typeof rule === 'function') {\r\n          return rule(fieldContext);\r\n        }\r\n        return rule;\r\n      });\r\n    };\r\n    _this.refresh = function () {\r\n      if (!_this.mounted) return;\r\n      /**\r\n       * Clean up current node.\r\n       */\r\n      _this.setState(function (_ref) {\r\n        var resetCount = _ref.resetCount;\r\n        return {\r\n          resetCount: resetCount + 1\r\n        };\r\n      });\r\n    };\r\n    // Event should only trigger when meta changed\r\n    _this.metaCache = null;\r\n    _this.triggerMetaEvent = function (destroy) {\r\n      var onMetaChange = _this.props.onMetaChange;\r\n      if (onMetaChange) {\r\n        var meta = _objectSpread(_objectSpread({}, _this.getMeta()), {}, {\r\n          destroy: destroy\r\n        });\r\n        if (!isEqual(_this.metaCache, meta)) {\r\n          onMetaChange(meta);\r\n        }\r\n        _this.metaCache = meta;\r\n      } else {\r\n        _this.metaCache = null;\r\n      }\r\n    };\r\n    // ========================= Field Entity Interfaces =========================\r\n    // Trigger by store update. Check if need update the component\r\n    _this.onStoreChange = function (prevStore, namePathList, info) {\r\n      var _this$props4 = _this.props,\r\n        shouldUpdate = _this$props4.shouldUpdate,\r\n        _this$props4$dependen = _this$props4.dependencies,\r\n        dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen,\r\n        onReset = _this$props4.onReset;\r\n      var store = info.store;\r\n      var namePath = _this.getNamePath();\r\n      var prevValue = _this.getValue(prevStore);\r\n      var curValue = _this.getValue(store);\r\n      var namePathMatch = namePathList && containsNamePath(namePathList, namePath);\r\n      // `setFieldsValue` is a quick access to update related status\r\n      if (info.type === 'valueUpdate' && info.source === 'external' && prevValue !== curValue) {\r\n        _this.touched = true;\r\n        _this.dirty = true;\r\n        _this.validatePromise = null;\r\n        _this.errors = EMPTY_ERRORS;\r\n        _this.warnings = EMPTY_ERRORS;\r\n        _this.triggerMetaEvent();\r\n      }\r\n      switch (info.type) {\r\n        case 'reset':\r\n          if (!namePathList || namePathMatch) {\r\n            // Clean up state\r\n            _this.touched = false;\r\n            _this.dirty = false;\r\n            _this.validatePromise = undefined;\r\n            _this.errors = EMPTY_ERRORS;\r\n            _this.warnings = EMPTY_ERRORS;\r\n            _this.triggerMetaEvent();\r\n            onReset === null || onReset === void 0 ? void 0 : onReset();\r\n            _this.refresh();\r\n            return;\r\n          }\r\n          break;\r\n        /**\r\n         * In case field with `preserve = false` nest deps like:\r\n         * - A = 1 => show B\r\n         * - B = 1 => show C\r\n         * - Reset A, need clean B, C\r\n         */\r\n        case 'remove':\r\n          {\r\n            if (shouldUpdate) {\r\n              _this.reRender();\r\n              return;\r\n            }\r\n            break;\r\n          }\r\n        case 'setField':\r\n          {\r\n            if (namePathMatch) {\r\n              var data = info.data;\r\n              if ('touched' in data) {\r\n                _this.touched = data.touched;\r\n              }\r\n              if ('validating' in data && !('originRCField' in data)) {\r\n                _this.validatePromise = data.validating ? Promise.resolve([]) : null;\r\n              }\r\n              if ('errors' in data) {\r\n                _this.errors = data.errors || EMPTY_ERRORS;\r\n              }\r\n              if ('warnings' in data) {\r\n                _this.warnings = data.warnings || EMPTY_ERRORS;\r\n              }\r\n              _this.dirty = true;\r\n              _this.triggerMetaEvent();\r\n              _this.reRender();\r\n              return;\r\n            }\r\n            // Handle update by `setField` with `shouldUpdate`\r\n            if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\r\n              _this.reRender();\r\n              return;\r\n            }\r\n            break;\r\n          }\r\n        case 'dependenciesUpdate':\r\n          {\r\n            /**\r\n             * Trigger when marked `dependencies` updated. Related fields will all update\r\n             */\r\n            var dependencyList = dependencies.map(getNamePath);\r\n            // No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be\r\n            // emitted earlier and they will work there\r\n            // If set it may cause unnecessary twice rerendering\r\n            if (dependencyList.some(function (dependency) {\r\n              return containsNamePath(info.relatedFields, dependency);\r\n            })) {\r\n              _this.reRender();\r\n              return;\r\n            }\r\n            break;\r\n          }\r\n        default:\r\n          // 1. If `namePath` exists in `namePathList`, means it's related value and should update\r\n          //      For example <List name=\"list\"><Field name={['list', 0]}></List>\r\n          //      If `namePathList` is [['list']] (List value update), Field should be updated\r\n          //      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated\r\n          // 2.\r\n          //   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,\r\n          //       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`\r\n          //       is not provided\r\n          //   2.2 If `shouldUpdate` provided, use customize logic to update the field\r\n          //       else to check if value changed\r\n          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\r\n            _this.reRender();\r\n            return;\r\n          }\r\n          break;\r\n      }\r\n      if (shouldUpdate === true) {\r\n        _this.reRender();\r\n      }\r\n    };\r\n    _this.validateRules = function (options) {\r\n      // We should fixed namePath & value to avoid developer change then by form function\r\n      var namePath = _this.getNamePath();\r\n      var currentValue = _this.getValue();\r\n      var _ref2 = options || {},\r\n        triggerName = _ref2.triggerName,\r\n        _ref2$validateOnly = _ref2.validateOnly,\r\n        validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;\r\n      // Force change to async to avoid rule OOD under renderProps field\r\n      var rootPromise = Promise.resolve().then(function () {\r\n        if (!_this.mounted) {\r\n          return [];\r\n        }\r\n        var _this$props5 = _this.props,\r\n          _this$props5$validate = _this$props5.validateFirst,\r\n          validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate,\r\n          messageVariables = _this$props5.messageVariables;\r\n        var filteredRules = _this.getRules();\r\n        if (triggerName) {\r\n          filteredRules = filteredRules.filter(function (rule) {\r\n            return rule;\r\n          }).filter(function (rule) {\r\n            var validateTrigger = rule.validateTrigger;\r\n            if (!validateTrigger) {\r\n              return true;\r\n            }\r\n            var triggerList = toArray(validateTrigger);\r\n            return triggerList.includes(triggerName);\r\n          });\r\n        }\r\n        var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);\r\n        promise.catch(function (e) {\r\n          return e;\r\n        }).then(function () {\r\n          var ruleErrors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_ERRORS;\r\n          if (_this.validatePromise === rootPromise) {\r\n            var _ruleErrors$forEach;\r\n            _this.validatePromise = null;\r\n            // Get errors & warnings\r\n            var nextErrors = [];\r\n            var nextWarnings = [];\r\n            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function (_ref3) {\r\n              var warningOnly = _ref3.rule.warningOnly,\r\n                _ref3$errors = _ref3.errors,\r\n                errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;\r\n              if (warningOnly) {\r\n                nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));\r\n              } else {\r\n                nextErrors.push.apply(nextErrors, _toConsumableArray(errors));\r\n              }\r\n            });\r\n            _this.errors = nextErrors;\r\n            _this.warnings = nextWarnings;\r\n            _this.triggerMetaEvent();\r\n            _this.reRender();\r\n          }\r\n        });\r\n        return promise;\r\n      });\r\n      if (validateOnly) {\r\n        return rootPromise;\r\n      }\r\n      _this.validatePromise = rootPromise;\r\n      _this.dirty = true;\r\n      _this.errors = EMPTY_ERRORS;\r\n      _this.warnings = EMPTY_ERRORS;\r\n      _this.triggerMetaEvent();\r\n      // Force trigger re-render since we need sync renderProps with new meta\r\n      _this.reRender();\r\n      return rootPromise;\r\n    };\r\n    _this.isFieldValidating = function () {\r\n      return !!_this.validatePromise;\r\n    };\r\n    _this.isFieldTouched = function () {\r\n      return _this.touched;\r\n    };\r\n    _this.isFieldDirty = function () {\r\n      // Touched or validate or has initialValue\r\n      if (_this.dirty || _this.props.initialValue !== undefined) {\r\n        return true;\r\n      }\r\n      // Form set initialValue\r\n      var fieldContext = _this.props.fieldContext;\r\n      var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK),\r\n        getInitialValue = _fieldContext$getInte.getInitialValue;\r\n      if (getInitialValue(_this.getNamePath()) !== undefined) {\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n    _this.getErrors = function () {\r\n      return _this.errors;\r\n    };\r\n    _this.getWarnings = function () {\r\n      return _this.warnings;\r\n    };\r\n    _this.isListField = function () {\r\n      return _this.props.isListField;\r\n    };\r\n    _this.isList = function () {\r\n      return _this.props.isList;\r\n    };\r\n    _this.isPreserve = function () {\r\n      return _this.props.preserve;\r\n    };\r\n    // ============================= Child Component =============================\r\n    _this.getMeta = function () {\r\n      // Make error & validating in cache to save perf\r\n      _this.prevValidating = _this.isFieldValidating();\r\n      var meta = {\r\n        touched: _this.isFieldTouched(),\r\n        validating: _this.prevValidating,\r\n        errors: _this.errors,\r\n        warnings: _this.warnings,\r\n        name: _this.getNamePath(),\r\n        validated: _this.validatePromise === null\r\n      };\r\n      return meta;\r\n    };\r\n    // Only return validate child node. If invalidate, will do nothing about field.\r\n    _this.getOnlyChild = function (children) {\r\n      // Support render props\r\n      if (typeof children === 'function') {\r\n        var meta = _this.getMeta();\r\n        return _objectSpread(_objectSpread({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {\r\n          isFunction: true\r\n        });\r\n      }\r\n      // Filed element only\r\n      var childList = toChildrenArray(children);\r\n      if (childList.length !== 1 || ! /*#__PURE__*/React.isValidElement(childList[0])) {\r\n        return {\r\n          child: childList,\r\n          isFunction: false\r\n        };\r\n      }\r\n      return {\r\n        child: childList[0],\r\n        isFunction: false\r\n      };\r\n    };\r\n    // ============================== Field Control ==============================\r\n    _this.getValue = function (store) {\r\n      var getFieldsValue = _this.props.fieldContext.getFieldsValue;\r\n      var namePath = _this.getNamePath();\r\n      return getValue(store || getFieldsValue(true), namePath);\r\n    };\r\n    _this.getControlled = function () {\r\n      var childProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n      var _this$props6 = _this.props,\r\n        trigger = _this$props6.trigger,\r\n        validateTrigger = _this$props6.validateTrigger,\r\n        getValueFromEvent = _this$props6.getValueFromEvent,\r\n        normalize = _this$props6.normalize,\r\n        valuePropName = _this$props6.valuePropName,\r\n        getValueProps = _this$props6.getValueProps,\r\n        fieldContext = _this$props6.fieldContext;\r\n      var mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\r\n      var namePath = _this.getNamePath();\r\n      var getInternalHooks = fieldContext.getInternalHooks,\r\n        getFieldsValue = fieldContext.getFieldsValue;\r\n      var _getInternalHooks = getInternalHooks(HOOK_MARK),\r\n        dispatch = _getInternalHooks.dispatch;\r\n      var value = _this.getValue();\r\n      var mergedGetValueProps = getValueProps || function (val) {\r\n        return _defineProperty({}, valuePropName, val);\r\n      };\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      var originTriggerFunc = childProps[trigger];\r\n      var control = _objectSpread(_objectSpread({}, childProps), mergedGetValueProps(value));\r\n      // Add trigger\r\n      control[trigger] = function () {\r\n        // Mark as touched\r\n        _this.touched = true;\r\n        _this.dirty = true;\r\n        _this.triggerMetaEvent();\r\n        var newValue;\r\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n          args[_key] = arguments[_key];\r\n        }\r\n        if (getValueFromEvent) {\r\n          newValue = getValueFromEvent.apply(void 0, args);\r\n        } else {\r\n          newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));\r\n        }\r\n        if (normalize) {\r\n          newValue = normalize(newValue, value, getFieldsValue(true));\r\n        }\r\n        dispatch({\r\n          type: 'updateValue',\r\n          namePath: namePath,\r\n          value: newValue\r\n        });\r\n        if (originTriggerFunc) {\r\n          originTriggerFunc.apply(void 0, args);\r\n        }\r\n      };\r\n      // Add validateTrigger\r\n      var validateTriggerList = toArray(mergedValidateTrigger || []);\r\n      validateTriggerList.forEach(function (triggerName) {\r\n        // Wrap additional function of component, so that we can get latest value from store\r\n        var originTrigger = control[triggerName];\r\n        control[triggerName] = function () {\r\n          if (originTrigger) {\r\n            originTrigger.apply(void 0, arguments);\r\n          }\r\n          // Always use latest rules\r\n          var rules = _this.props.rules;\r\n          if (rules && rules.length) {\r\n            // We dispatch validate to root,\r\n            // since it will update related data with other field with same name\r\n            dispatch({\r\n              type: 'validateField',\r\n              namePath: namePath,\r\n              triggerName: triggerName\r\n            });\r\n          }\r\n        };\r\n      });\r\n      return control;\r\n    };\r\n    if (props.fieldContext) {\r\n      var getInternalHooks = props.fieldContext.getInternalHooks;\r\n      var _getInternalHooks2 = getInternalHooks(HOOK_MARK),\r\n        initEntityValue = _getInternalHooks2.initEntityValue;\r\n      initEntityValue(_assertThisInitialized(_this));\r\n    }\r\n    return _this;\r\n  }\r\n  _createClass(Field, [{\r\n    key: \"componentDidMount\",\r\n    value: function componentDidMount() {\r\n      var _this$props7 = this.props,\r\n        shouldUpdate = _this$props7.shouldUpdate,\r\n        fieldContext = _this$props7.fieldContext;\r\n      this.mounted = true;\r\n      // Register on init\r\n      if (fieldContext) {\r\n        var getInternalHooks = fieldContext.getInternalHooks;\r\n        var _getInternalHooks3 = getInternalHooks(HOOK_MARK),\r\n          registerField = _getInternalHooks3.registerField;\r\n        this.cancelRegisterFunc = registerField(this);\r\n      }\r\n      // One more render for component in case fields not ready\r\n      if (shouldUpdate === true) {\r\n        this.reRender();\r\n      }\r\n    }\r\n  }, {\r\n    key: \"componentWillUnmount\",\r\n    value: function componentWillUnmount() {\r\n      this.cancelRegister();\r\n      this.triggerMetaEvent(true);\r\n      this.mounted = false;\r\n    }\r\n  }, {\r\n    key: \"reRender\",\r\n    value: function reRender() {\r\n      if (!this.mounted) return;\r\n      this.forceUpdate();\r\n    }\r\n  }, {\r\n    key: \"render\",\r\n    value: function render() {\r\n      var resetCount = this.state.resetCount;\r\n      var children = this.props.children;\r\n      var _this$getOnlyChild = this.getOnlyChild(children),\r\n        child = _this$getOnlyChild.child,\r\n        isFunction = _this$getOnlyChild.isFunction;\r\n      // Not need to `cloneElement` since user can handle this in render function self\r\n      var returnChildNode;\r\n      if (isFunction) {\r\n        returnChildNode = child;\r\n      } else if ( /*#__PURE__*/React.isValidElement(child)) {\r\n        returnChildNode = /*#__PURE__*/React.cloneElement(child, this.getControlled(child.props));\r\n      } else {\r\n        warning(!child, '`children` of Field is not validate ReactElement.');\r\n        returnChildNode = child;\r\n      }\r\n      return /*#__PURE__*/React.createElement(React.Fragment, {\r\n        key: resetCount\r\n      }, returnChildNode);\r\n    }\r\n  }]);\r\n  return Field;\r\n}(React.Component);\r\nField.contextType = FieldContext;\r\nField.defaultProps = {\r\n  trigger: 'onChange',\r\n  valuePropName: 'value'\r\n};\r\nfunction WrapperField(_ref5) {\r\n  var name = _ref5.name,\r\n    restProps = _objectWithoutProperties(_ref5, _excluded);\r\n  var fieldContext = React.useContext(FieldContext);\r\n  var listContext = React.useContext(ListContext);\r\n  var namePath = name !== undefined ? getNamePath(name) : undefined;\r\n  var key = 'keep';\r\n  if (!restProps.isListField) {\r\n    key = \"_\".concat((namePath || []).join('_'));\r\n  }\r\n  // Warning if it's a directly list field.\r\n  // We can still support multiple level field preserve.\r\n  if (process.env.NODE_ENV !== 'production' && restProps.preserve === false && restProps.isListField && namePath.length <= 1) {\r\n    warning(false, '`preserve` should not apply on Form.List fields.');\r\n  }\r\n  return /*#__PURE__*/React.createElement(Field, _extends({\r\n    key: key,\r\n    name: namePath,\r\n    isListField: !!listContext\r\n  }, restProps, {\r\n    fieldContext: fieldContext\r\n  }));\r\n}\r\nexport default WrapperField;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}