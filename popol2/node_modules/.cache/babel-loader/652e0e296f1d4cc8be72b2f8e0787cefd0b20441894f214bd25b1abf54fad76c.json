{"ast":null,"code":"'use client';\n\nimport _slicedToArray from \"C:/Users/user/Desktop/MusicHub-ec2/popol2/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nfunction areEqual(a, b) {\n  return a === b;\n}\nvar EMPTY_OBJECT = {};\nvar NOOP = function NOOP() {};\n\n/**\r\n * Gets the current state augmented with controlled values from the outside.\r\n * If a state item has a corresponding controlled value, it will be used instead of the internal state.\r\n */\nfunction getControlledState(internalState, controlledProps) {\n  var augmentedState = _extends({}, internalState);\n  Object.keys(controlledProps).forEach(function (key) {\n    if (controlledProps[key] !== undefined) {\n      augmentedState[key] = controlledProps[key];\n    }\n  });\n  return augmentedState;\n}\n/**\r\n * Defines an effect that compares the next state with the previous state and calls\r\n * the `onStateChange` callback if the state has changed.\r\n * The comparison is done based on the `stateComparers` parameter.\r\n */\nfunction useStateChangeDetection(parameters) {\n  var nextState = parameters.nextState,\n    initialState = parameters.initialState,\n    stateComparers = parameters.stateComparers,\n    onStateChange = parameters.onStateChange,\n    controlledProps = parameters.controlledProps,\n    lastActionRef = parameters.lastActionRef;\n  var internalPreviousStateRef = React.useRef(initialState);\n  React.useEffect(function () {\n    if (lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n    var previousState = getControlledState(internalPreviousStateRef.current, controlledProps);\n    Object.keys(nextState).forEach(function (key) {\n      var _stateComparers$key;\n      // go through all state keys and compare them with the previous state\n      var stateComparer = (_stateComparers$key = stateComparers[key]) != null ? _stateComparers$key : areEqual;\n      var nextStateItem = nextState[key];\n      var previousStateItem = previousState[key];\n      if (previousStateItem == null && nextStateItem != null || previousStateItem != null && nextStateItem == null || previousStateItem != null && nextStateItem != null && !stateComparer(nextStateItem, previousStateItem)) {\n        var _event, _type;\n        onStateChange == null || onStateChange((_event = lastActionRef.current.event) != null ? _event : null, key, nextStateItem, (_type = lastActionRef.current.type) != null ? _type : '', nextState);\n      }\n    });\n    internalPreviousStateRef.current = nextState;\n    lastActionRef.current = null;\n  }, [internalPreviousStateRef, nextState, lastActionRef, onStateChange, stateComparers, controlledProps]);\n}\n\n/**\r\n * The alternative to `React.useReducer` that lets you control the state from the outside.\r\n *\r\n * It can be used in an uncontrolled mode, similar to `React.useReducer`, or in a controlled mode, when the state is controlled by the props.\r\n * It also supports partially controlled state, when some state items are controlled and some are not.\r\n *\r\n * The controlled state items are provided via the `controlledProps` parameter.\r\n * When a reducer action is dispatched, the internal state is updated with the new values.\r\n * A change event (`onStateChange`) is then triggered (for each changed state item) if the new state is different from the previous state.\r\n * This event can be used to update the controlled values.\r\n *\r\n * The comparison of the previous and next states is done using the `stateComparers` parameter.\r\n * If a state item has a corresponding comparer, it will be used to determine if the state has changed.\r\n * This is useful when the state item is an object and you want to compare only a subset of its properties or if it's an array and you want to compare its contents.\r\n *\r\n * An additional feature is the `actionContext` parameter. It allows you to add additional properties to every action object,\r\n * similarly to how React context is implicitly available to every component.\r\n *\r\n * @template State - The type of the state calculated by the reducer.\r\n * @template Action - The type of the actions that can be dispatched.\r\n * @template ActionContext - The type of the additional properties that will be added to every action object.\r\n *\r\n * @ignore - internal hook.\r\n */\nexport function useControllableReducer(parameters) {\n  var lastActionRef = React.useRef(null);\n  var reducer = parameters.reducer,\n    initialState = parameters.initialState,\n    _parameters$controlle = parameters.controlledProps,\n    controlledProps = _parameters$controlle === void 0 ? EMPTY_OBJECT : _parameters$controlle,\n    _parameters$stateComp = parameters.stateComparers,\n    stateComparers = _parameters$stateComp === void 0 ? EMPTY_OBJECT : _parameters$stateComp,\n    _parameters$onStateCh = parameters.onStateChange,\n    onStateChange = _parameters$onStateCh === void 0 ? NOOP : _parameters$onStateCh,\n    actionContext = parameters.actionContext,\n    _parameters$component = parameters.componentName,\n    componentName = _parameters$component === void 0 ? '' : _parameters$component;\n  var controlledPropsRef = React.useRef(controlledProps);\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(function () {\n      Object.keys(controlledProps).forEach(function (key) {\n        if (controlledPropsRef.current[key] !== undefined && controlledProps[key] === undefined) {\n          console.error(\"useControllableReducer: \".concat(componentName ? \"The \".concat(componentName, \" component\") : 'A component', \" is changing a controlled prop to be uncontrolled: \").concat(key));\n        }\n        if (controlledPropsRef.current[key] === undefined && controlledProps[key] !== undefined) {\n          console.error(\"useControllableReducer: \".concat(componentName ? \"The \".concat(componentName, \" component\") : 'A component', \" is changing an uncontrolled prop to be controlled: \").concat(key));\n        }\n      });\n    }, [controlledProps, componentName]);\n  }\n\n  // The reducer that is passed to React.useReducer is wrapped with a function that augments the state with controlled values.\n  var reducerWithControlledState = React.useCallback(function (state, action) {\n    lastActionRef.current = action;\n    var controlledState = getControlledState(state, controlledProps);\n    var newState = reducer(controlledState, action);\n    return newState;\n  }, [controlledProps, reducer]);\n  var _React$useReducer = React.useReducer(reducerWithControlledState, initialState),\n    _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n    nextState = _React$useReducer2[0],\n    dispatch = _React$useReducer2[1];\n\n  // The action that is passed to dispatch is augmented with the actionContext.\n  var dispatchWithContext = React.useCallback(function (action) {\n    dispatch(_extends({}, action, {\n      context: actionContext\n    }));\n  }, [actionContext]);\n  useStateChangeDetection({\n    nextState: nextState,\n    initialState: initialState,\n    stateComparers: stateComparers != null ? stateComparers : EMPTY_OBJECT,\n    onStateChange: onStateChange != null ? onStateChange : NOOP,\n    controlledProps: controlledProps,\n    lastActionRef: lastActionRef\n  });\n  return [getControlledState(nextState, controlledProps), dispatchWithContext];\n}","map":{"version":3,"names":["_slicedToArray","_extends","React","areEqual","a","b","EMPTY_OBJECT","NOOP","getControlledState","internalState","controlledProps","augmentedState","Object","keys","forEach","key","undefined","useStateChangeDetection","parameters","nextState","initialState","stateComparers","onStateChange","lastActionRef","internalPreviousStateRef","useRef","useEffect","current","previousState","_stateComparers$key","stateComparer","nextStateItem","previousStateItem","_event","_type","event","type","useControllableReducer","reducer","_parameters$controlle","_parameters$stateComp","_parameters$onStateCh","actionContext","_parameters$component","componentName","controlledPropsRef","process","env","NODE_ENV","console","error","concat","reducerWithControlledState","useCallback","state","action","controlledState","newState","_React$useReducer","useReducer","_React$useReducer2","dispatch","dispatchWithContext","context"],"sources":["C:/Users/user/Desktop/MusicHub-ec2/popol2/node_modules/@mui/base/utils/useControllableReducer.js"],"sourcesContent":["'use client';\r\n\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport * as React from 'react';\r\nfunction areEqual(a, b) {\r\n  return a === b;\r\n}\r\nconst EMPTY_OBJECT = {};\r\nconst NOOP = () => {};\r\n\r\n/**\r\n * Gets the current state augmented with controlled values from the outside.\r\n * If a state item has a corresponding controlled value, it will be used instead of the internal state.\r\n */\r\nfunction getControlledState(internalState, controlledProps) {\r\n  const augmentedState = _extends({}, internalState);\r\n  Object.keys(controlledProps).forEach(key => {\r\n    if (controlledProps[key] !== undefined) {\r\n      augmentedState[key] = controlledProps[key];\r\n    }\r\n  });\r\n  return augmentedState;\r\n}\r\n/**\r\n * Defines an effect that compares the next state with the previous state and calls\r\n * the `onStateChange` callback if the state has changed.\r\n * The comparison is done based on the `stateComparers` parameter.\r\n */\r\nfunction useStateChangeDetection(parameters) {\r\n  const {\r\n    nextState,\r\n    initialState,\r\n    stateComparers,\r\n    onStateChange,\r\n    controlledProps,\r\n    lastActionRef\r\n  } = parameters;\r\n  const internalPreviousStateRef = React.useRef(initialState);\r\n  React.useEffect(() => {\r\n    if (lastActionRef.current === null) {\r\n      // Detect changes only if an action has been dispatched.\r\n      return;\r\n    }\r\n    const previousState = getControlledState(internalPreviousStateRef.current, controlledProps);\r\n    Object.keys(nextState).forEach(key => {\r\n      var _stateComparers$key;\r\n      // go through all state keys and compare them with the previous state\r\n      const stateComparer = (_stateComparers$key = stateComparers[key]) != null ? _stateComparers$key : areEqual;\r\n      const nextStateItem = nextState[key];\r\n      const previousStateItem = previousState[key];\r\n      if (previousStateItem == null && nextStateItem != null || previousStateItem != null && nextStateItem == null || previousStateItem != null && nextStateItem != null && !stateComparer(nextStateItem, previousStateItem)) {\r\n        var _event, _type;\r\n        onStateChange == null || onStateChange((_event = lastActionRef.current.event) != null ? _event : null, key, nextStateItem, (_type = lastActionRef.current.type) != null ? _type : '', nextState);\r\n      }\r\n    });\r\n    internalPreviousStateRef.current = nextState;\r\n    lastActionRef.current = null;\r\n  }, [internalPreviousStateRef, nextState, lastActionRef, onStateChange, stateComparers, controlledProps]);\r\n}\r\n\r\n/**\r\n * The alternative to `React.useReducer` that lets you control the state from the outside.\r\n *\r\n * It can be used in an uncontrolled mode, similar to `React.useReducer`, or in a controlled mode, when the state is controlled by the props.\r\n * It also supports partially controlled state, when some state items are controlled and some are not.\r\n *\r\n * The controlled state items are provided via the `controlledProps` parameter.\r\n * When a reducer action is dispatched, the internal state is updated with the new values.\r\n * A change event (`onStateChange`) is then triggered (for each changed state item) if the new state is different from the previous state.\r\n * This event can be used to update the controlled values.\r\n *\r\n * The comparison of the previous and next states is done using the `stateComparers` parameter.\r\n * If a state item has a corresponding comparer, it will be used to determine if the state has changed.\r\n * This is useful when the state item is an object and you want to compare only a subset of its properties or if it's an array and you want to compare its contents.\r\n *\r\n * An additional feature is the `actionContext` parameter. It allows you to add additional properties to every action object,\r\n * similarly to how React context is implicitly available to every component.\r\n *\r\n * @template State - The type of the state calculated by the reducer.\r\n * @template Action - The type of the actions that can be dispatched.\r\n * @template ActionContext - The type of the additional properties that will be added to every action object.\r\n *\r\n * @ignore - internal hook.\r\n */\r\nexport function useControllableReducer(parameters) {\r\n  const lastActionRef = React.useRef(null);\r\n  const {\r\n    reducer,\r\n    initialState,\r\n    controlledProps = EMPTY_OBJECT,\r\n    stateComparers = EMPTY_OBJECT,\r\n    onStateChange = NOOP,\r\n    actionContext,\r\n    componentName = ''\r\n  } = parameters;\r\n  const controlledPropsRef = React.useRef(controlledProps);\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    React.useEffect(() => {\r\n      Object.keys(controlledProps).forEach(key => {\r\n        if (controlledPropsRef.current[key] !== undefined && controlledProps[key] === undefined) {\r\n          console.error(`useControllableReducer: ${componentName ? `The ${componentName} component` : 'A component'} is changing a controlled prop to be uncontrolled: ${key}`);\r\n        }\r\n        if (controlledPropsRef.current[key] === undefined && controlledProps[key] !== undefined) {\r\n          console.error(`useControllableReducer: ${componentName ? `The ${componentName} component` : 'A component'} is changing an uncontrolled prop to be controlled: ${key}`);\r\n        }\r\n      });\r\n    }, [controlledProps, componentName]);\r\n  }\r\n\r\n  // The reducer that is passed to React.useReducer is wrapped with a function that augments the state with controlled values.\r\n  const reducerWithControlledState = React.useCallback((state, action) => {\r\n    lastActionRef.current = action;\r\n    const controlledState = getControlledState(state, controlledProps);\r\n    const newState = reducer(controlledState, action);\r\n    return newState;\r\n  }, [controlledProps, reducer]);\r\n  const [nextState, dispatch] = React.useReducer(reducerWithControlledState, initialState);\r\n\r\n  // The action that is passed to dispatch is augmented with the actionContext.\r\n  const dispatchWithContext = React.useCallback(action => {\r\n    dispatch(_extends({}, action, {\r\n      context: actionContext\r\n    }));\r\n  }, [actionContext]);\r\n  useStateChangeDetection({\r\n    nextState,\r\n    initialState,\r\n    stateComparers: stateComparers != null ? stateComparers : EMPTY_OBJECT,\r\n    onStateChange: onStateChange != null ? onStateChange : NOOP,\r\n    controlledProps,\r\n    lastActionRef\r\n  });\r\n  return [getControlledState(nextState, controlledProps), dispatchWithContext];\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}